{"ast":null,"code":"import t, { useEffect as e, useCallback as n, createElement as r, Fragment as o } from \"react\";\nimport { useService as a } from \"@xstate/react\";\nimport { addSeconds as i, isAfter as u, differenceInSeconds as c } from \"date-fns\";\nimport { Machine as s, assign as l, interpret as h } from \"xstate\";\nimport { choose as f } from \"xstate/lib/actions\";\n\nvar g = function (n) {\n  var r = n.children;\n  return e(function () {\n    console.error(\"The AuthProvider root component no longer works. Please take 5min to migrate to AuthConfig. ðŸ‘‰ https://useauth.dev/docs/upgrading\");\n  }, []), t.createElement(t.Fragment, null, r);\n};\n\nfunction d() {\n  return (d = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nvar p = h(s({\n  id: \"useAuth\",\n  initial: \"unauthenticated\",\n  context: {\n    user: {},\n    expiresAt: null,\n    authResult: null,\n    isAuthenticating: !1,\n    error: void 0,\n    errorType: void 0,\n    config: {\n      navigate: function () {\n        return console.error(\"Please specify a navigation method that works with your router\");\n      },\n      callbackDomain: \"http://localhost:8000\"\n    }\n  },\n  states: {\n    unauthenticated: {\n      on: {\n        LOGIN: \"authenticating\",\n        CHECK_SESSION: \"verifying\",\n        SET_CONFIG: {\n          actions: [\"setConfig\"]\n        }\n      }\n    },\n    authenticating: {\n      on: {\n        ERROR: \"error\",\n        AUTHENTICATED: \"authenticated\",\n        SET_CONFIG: {\n          actions: [\"setConfig\"]\n        }\n      },\n      entry: [\"startAuthenticating\"],\n      exit: [\"stopAuthenticating\"]\n    },\n    verifying: {\n      invoke: {\n        id: \"checkSession\",\n        src: function (t, e) {\n          return t.config.authProvider.checkSession();\n        },\n        onDone: {\n          target: \"authenticated\"\n        },\n        onError: {\n          target: \"unauthenticated\",\n          actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n        }\n      },\n      entry: [\"startAuthenticating\"],\n      exit: [\"stopAuthenticating\"]\n    },\n    authenticated: {\n      on: {\n        LOGOUT: \"unauthenticated\",\n        SET_CONFIG: {\n          actions: [\"setConfig\"]\n        },\n        CHECK_SESSION: \"verifying\"\n      },\n      entry: [\"saveUserToContext\", \"saveToLocalStorage\"],\n      exit: f([{\n        cond: function (t, e) {\n          return \"CHECK_SESSION\" !== e.type;\n        },\n        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n      }])\n    },\n    error: {\n      entry: [\"saveErrorToContext\", \"clearUserFromContext\", \"clearLocalStorage\"]\n    }\n  }\n}, {\n  actions: {\n    startAuthenticating: l(function (t) {\n      return {\n        isAuthenticating: !0\n      };\n    }),\n    stopAuthenticating: l(function (t) {\n      return {\n        isAuthenticating: !1\n      };\n    }),\n    saveUserToContext: l(function (t, e) {\n      var n = e.data ? e.data : e,\n          r = n.authResult;\n      return {\n        user: n.user,\n        authResult: r,\n        expiresAt: i(new Date(), r.expiresIn)\n      };\n    }),\n    clearUserFromContext: l(function (t) {\n      return {\n        user: {},\n        expiresAt: null,\n        authResult: null\n      };\n    }),\n    saveToLocalStorage: function (t, e) {\n      var n = t.expiresAt,\n          r = t.user;\n      \"undefined\" != typeof localStorage && (localStorage.setItem(\"useAuth:expires_at\", n ? n.toISOString() : \"0\"), localStorage.setItem(\"useAuth:user\", JSON.stringify(r)));\n    },\n    clearLocalStorage: function () {\n      \"undefined\" != typeof localStorage && (localStorage.removeItem(\"useAuth:expires_at\"), localStorage.removeItem(\"useAuth:user\"));\n    },\n    saveErrorToContext: l(function (t, e) {\n      return {\n        errorType: e.errorType,\n        error: e.error\n      };\n    }),\n    setConfig: l(function (t, e) {\n      return {\n        config: d({}, t.config, e)\n      };\n    })\n  }\n}));\np.start(), function (t) {\n  if (\"undefined\" != typeof localStorage) {\n    var e = new Date(localStorage.getItem(\"useAuth:expires_at\") || \"0\"),\n        n = new Date();\n\n    if (u(e, n)) {\n      var r = JSON.parse(localStorage.getItem(\"useAuth:user\") || \"{}\");\n      t(\"LOGIN\"), t(\"AUTHENTICATED\", {\n        user: r,\n        authResult: {\n          expiresIn: c(e, n)\n        }\n      });\n    }\n  }\n}(p.send);\n\nvar v = function () {\n  var t = a(p),\n      e = t[0],\n      r = t[1],\n      o = e.context.config,\n      i = o.authProvider,\n      c = o.navigate,\n      s = o.callbackDomain,\n      l = n(function (t) {\n    var e = (void 0 === t ? {} : t).postLoginRoute,\n        n = void 0 === e ? \"/\" : e;\n\n    try {\n      if (!i || !c) return console.warn(\"authProvider not configured yet\"), Promise.resolve();\n\n      var o = function () {\n        if (\"undefined\" != typeof window) return r(\"LOGIN\"), Promise.resolve(i.handleLoginCallback(r)).then(function (t) {\n          t && c(n);\n        });\n      }();\n\n      return Promise.resolve(o && o.then ? o.then(function () {}) : void 0);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, [i, c]),\n      h = function () {\n    return !(!e.context.expiresAt || !u(e.context.expiresAt, new Date()));\n  };\n\n  return {\n    isAuthenticating: e.context.isAuthenticating,\n    isAuthenticated: h,\n    isAuthorized: function (t) {\n      var n = Array.isArray(t) ? t : [t],\n          r = null == i ? void 0 : i.userRoles(e.context.user);\n      return !(!h() || !r) && n.some(function (t) {\n        return r.includes(t);\n      });\n    },\n    user: e.context.user,\n    userId: null == i ? void 0 : i.userId(e.context.user),\n    authResult: e.context.authResult,\n    login: function () {\n      null == i || i.authorize();\n    },\n    signup: function () {\n      null == i || i.signup();\n    },\n    logout: function (t) {\n      \"string\" == typeof t ? null == i || i.logout(\"\" + s + t) : null == i || i.logout(), r(\"LOGOUT\"), c(\"string\" == typeof t ? t : \"/\");\n    },\n    handleAuthentication: l,\n    dispatch: r\n  };\n},\n    m = function (t) {\n  var n = t.authProvider,\n      a = t.params,\n      i = t.navigate,\n      u = t.children,\n      c = v().dispatch,\n      s = \"undefined\" != typeof window ? window.location.protocol + \"//\" + window.location.host : \"http://localhost:8000\";\n  return e(function () {\n    var t = new n(d({\n      dispatch: c\n    }, n.addDefaultParams(a, s)));\n    c(\"SET_CONFIG\", {\n      authProvider: t,\n      navigate: i,\n      callbackDomain: s\n    }), c(\"CHECK_SESSION\");\n  }, [c, n, a, i]), r(o, null, u);\n};\n\nexport { m as AuthConfig, g as AuthProvider, v as useAuth };","map":{"version":3,"mappings":"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","names":["AuthProvider","children","useEffect","console","error","React","Fragment","authService","interpret","Machine","id","initial","context","user","expiresAt","authResult","isAuthenticating","undefined","errorType","config","navigate","callbackDomain","states","unauthenticated","on","LOGIN","CHECK_SESSION","SET_CONFIG","actions","authenticating","ERROR","AUTHENTICATED","entry","exit","verifying","invoke","src","event","authProvider","checkSession","onDone","target","onError","authenticated","LOGOUT","choose","cond","type","startAuthenticating","assign","stopAuthenticating","saveUserToContext","data","addSeconds","Date","expiresIn","clearUserFromContext","saveToLocalStorage","localStorage","setItem","toISOString","JSON","stringify","clearLocalStorage","removeItem","saveErrorToContext","setConfig","start","send","getItem","now","isAfter","parse","differenceInSeconds","hydrateFromLocalStorage","useAuth","useService","state","dispatch","handleAuthentication","useCallback","t","postLoginRoute","e","warn","Promise","window","handleLoginCallback","loggedIn","isAuthenticated","isAuthorized","roles","_roles","Array","isArray","userRoles","some","role","includes","userId","login","authorize","signup","logout","postLogoutRoute","AuthConfig","params","location","protocol","host","authInstance","addDefaultParams"],"sources":["/home/andrespardo/Desktop/react chuck/chuch/node_modules/react-use-auth/src/AuthProvider.tsx","/home/andrespardo/Desktop/react chuck/chuch/node_modules/react-use-auth/src/authReducer.ts","/home/andrespardo/Desktop/react chuck/chuch/node_modules/react-use-auth/src/useAuth.ts","/home/andrespardo/Desktop/react chuck/chuch/node_modules/react-use-auth/src/AuthConfig.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\nimport { AuthOptions as Auth0Options } from \"auth0-js\";\n\nimport { AuthProviderInterface } from \"./types\";\nimport { useAuth } from \"./useAuth\";\n// import { Auth0 } from \"./providers/auth0\";\n\nexport const AuthProvider: AuthProviderInterface = ({\n    children,\n    navigate,\n    auth0_audience_domain,\n    auth0_domain,\n    auth0_client_id,\n    auth0_params = {},\n    customPropertyNamespace\n}) => {\n    useEffect(() => {\n        console.error(\n            \"The AuthProvider root component no longer works. Please take 5min to migrate to AuthConfig. ðŸ‘‰ https://useauth.dev/docs/upgrading\"\n        );\n    }, []);\n\n    return <React.Fragment>{children}</React.Fragment>;\n};\n","import { addSeconds, differenceInSeconds, isAfter } from \"date-fns\";\nimport { Machine, assign, interpret } from \"xstate\";\nimport { choose } from \"xstate/lib/actions\";\nimport { AuthState } from \"./types\";\n\nexport const authMachine = Machine<AuthState>(\n    {\n        id: \"useAuth\",\n        initial: \"unauthenticated\",\n        context: {\n            user: {},\n            expiresAt: null,\n            authResult: null,\n            isAuthenticating: false,\n            error: undefined,\n            errorType: undefined,\n            config: {\n                navigate: () =>\n                    console.error(\n                        \"Please specify a navigation method that works with your router\"\n                    ),\n                // TODO: detect default\n                callbackDomain: \"http://localhost:8000\"\n            }\n        },\n        states: {\n            unauthenticated: {\n                on: {\n                    LOGIN: \"authenticating\",\n                    CHECK_SESSION: \"verifying\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                }\n            },\n            authenticating: {\n                on: {\n                    ERROR: \"error\",\n                    AUTHENTICATED: \"authenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            verifying: {\n                invoke: {\n                    id: \"checkSession\",\n                    src: (context, event) =>\n                        context.config.authProvider!.checkSession(),\n                    onDone: {\n                        target: \"authenticated\"\n                    },\n                    onError: {\n                        target: \"unauthenticated\",\n                        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            authenticated: {\n                on: {\n                    LOGOUT: \"unauthenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    },\n                    CHECK_SESSION: \"verifying\"\n                },\n                entry: [\"saveUserToContext\", \"saveToLocalStorage\"],\n                exit: choose([\n                    {\n                        cond: (context, event) =>\n                            event.type !== \"CHECK_SESSION\",\n                        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n                    }\n                ])\n            },\n            error: {\n                entry: [\n                    \"saveErrorToContext\",\n                    \"clearUserFromContext\",\n                    \"clearLocalStorage\"\n                ]\n            }\n        }\n    },\n    {\n        actions: {\n            startAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: true\n                };\n            }),\n            stopAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: false\n                };\n            }),\n            saveUserToContext: assign((context, event) => {\n                const { authResult, user } = event.data ? event.data : event;\n                const expiresAt = addSeconds(new Date(), authResult.expiresIn);\n\n                return {\n                    user,\n                    authResult,\n                    expiresAt\n                };\n            }),\n            clearUserFromContext: assign(context => {\n                return {\n                    user: {},\n                    expiresAt: null,\n                    authResult: null\n                };\n            }),\n            saveToLocalStorage: (context, event) => {\n                const { expiresAt, user } = context;\n\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(\n                        \"useAuth:expires_at\",\n                        expiresAt ? expiresAt.toISOString() : \"0\"\n                    );\n                    localStorage.setItem(\"useAuth:user\", JSON.stringify(user));\n                }\n            },\n            clearLocalStorage: () => {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.removeItem(\"useAuth:expires_at\");\n                    localStorage.removeItem(\"useAuth:user\");\n                }\n            },\n            saveErrorToContext: assign((context, event) => {\n                return {\n                    errorType: event.errorType,\n                    error: event.error\n                };\n            }),\n            setConfig: assign((context, event) => {\n                return {\n                    config: {\n                        ...context.config,\n                        ...event\n                    }\n                };\n            })\n        }\n    }\n);\n\n// check localstorage and login as soon as this file loads\nfunction hydrateFromLocalStorage(send: any) {\n    if (typeof localStorage !== \"undefined\") {\n        const expiresAt = new Date(\n                localStorage.getItem(\"useAuth:expires_at\") || \"0\"\n            ),\n            now = new Date();\n\n        if (isAfter(expiresAt, now)) {\n            const user = JSON.parse(\n                localStorage.getItem(\"useAuth:user\") || \"{}\"\n            );\n            send(\"LOGIN\");\n            send(\"AUTHENTICATED\", {\n                user,\n                authResult: {\n                    expiresIn: differenceInSeconds(expiresAt, now)\n                }\n            });\n        }\n    }\n}\n\nexport const authService = interpret(authMachine);\nauthService.start();\n\nhydrateFromLocalStorage(authService.send);\n","import { useCallback } from \"react\";\n\nimport { useAuthInterface } from \"./types\";\nimport { useService } from \"@xstate/react\";\nimport { authService } from \"./authReducer\";\nimport { isAfter } from \"date-fns\";\n\n/**\n * The main API for useAuth\n *\n * @return {boolean} isAuthenticated is current user authenticated\n * @return {boolean} isAuthenticating currently running authentication\n * @return {function} isAuthorized check if current user is authenticated and matches list of roles\n * @return {object} user current user\n * @return {string} userId current user's identifier\n * @return {object} authResult raw authentication result object from auth provider\n * @return {function} login start the login process\n * @return {function} signup same as login, passes { mode: \"signUp\", screen_hint: \"signup\" } to Auth0\n * @return {function} logout start the logout process\n * @return {function} handleAuthentication function to call on your callback page\n */\nexport const useAuth: useAuthInterface = () => {\n    const [state, dispatch] = useService(authService);\n\n    const { authProvider, navigate, callbackDomain } = state.context.config;\n\n    const login = () => {\n        authProvider?.authorize();\n    };\n\n    const signup = () => {\n        authProvider?.signup();\n    };\n\n    const logout = (postLogoutRoute?: string) => {\n        // React sends a click event by default, we don't care\n        if (typeof postLogoutRoute === \"string\") {\n            authProvider?.logout(`${callbackDomain}${postLogoutRoute}`);\n        } else {\n            authProvider?.logout();\n        }\n\n        dispatch(\"LOGOUT\");\n\n        // Return to the homepage after logout.\n        navigate(typeof postLogoutRoute === \"string\" ? postLogoutRoute : \"/\");\n    };\n\n    const handleAuthentication = useCallback(\n        async ({ postLoginRoute = \"/\" } = {}) => {\n            if (!authProvider || !navigate) {\n                console.warn(\"authProvider not configured yet\");\n                return;\n            }\n\n            if (typeof window !== \"undefined\") {\n                dispatch(\"LOGIN\");\n\n                const loggedIn = await authProvider.handleLoginCallback(\n                    dispatch\n                );\n\n                if (loggedIn) {\n                    navigate(postLoginRoute);\n                }\n            }\n        },\n        [authProvider, navigate]\n    );\n\n    const isAuthenticated = () => {\n        return !!(\n            state.context.expiresAt &&\n            isAfter(state.context.expiresAt, new Date())\n        );\n    };\n\n    const isAuthorized = (roles: string | string[]) => {\n        const _roles = Array.isArray(roles) ? roles : [roles];\n        const userRoles = authProvider?.userRoles(state.context.user);\n\n        if (!isAuthenticated() || !userRoles) {\n            return false;\n        } else {\n            return _roles.some(role => userRoles.includes(role));\n        }\n    };\n\n    return {\n        isAuthenticating: state.context.isAuthenticating,\n        isAuthenticated,\n        isAuthorized,\n        user: state.context.user,\n        userId: authProvider?.userId(state.context.user),\n        authResult: state.context.authResult,\n        login,\n        signup,\n        logout,\n        handleAuthentication,\n        dispatch\n    };\n};\n","import * as React from \"react\";\nimport { AuthConfigInterface, ProviderOptions } from \"./types\";\nimport { useAuth } from \"./useAuth\";\n\nexport const AuthConfig: AuthConfigInterface = ({\n    authProvider,\n    params,\n    navigate,\n    children\n}) => {\n    const { dispatch } = useAuth();\n\n    const callbackDomain =\n        typeof window !== \"undefined\"\n            ? `${window.location.protocol}//${window.location.host}`\n            : \"http://localhost:8000\";\n\n    React.useEffect(() => {\n        // instantiate auth provider on page load\n        const authInstance = new authProvider({\n            dispatch,\n            ...authProvider.addDefaultParams(\n                params as ProviderOptions,\n                callbackDomain\n            )\n        });\n\n        // set config in XState\n        dispatch(\"SET_CONFIG\", {\n            authProvider: authInstance,\n            navigate,\n            callbackDomain\n        });\n\n        dispatch(\"CHECK_SESSION\");\n    }, [dispatch, authProvider, params, navigate]);\n\n    return <>{children}</>;\n};\n"]},"metadata":{},"sourceType":"module"}